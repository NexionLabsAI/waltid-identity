name: Automate Release Build

on:
  push:
    branches:
      - dev

permissions:
  id-token: write
  contents: write

jobs:
  create-tag:
    runs-on: ubuntu-latest
    environment: development
    outputs:
      new_tag: ${{ steps.generate_tag.outputs.new_tag }}
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-ecs-role
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Generate new version
        id: generate_tag
        run: |
          # Define all repository names
          REPOS=("waltid-issuer-api" "waltid-verifier-api" "waltid-wallet-api" "waltid-demo-wallet" "waltid-web-portal")
          LATEST_VERSION="0.0.0"

          # Find the highest version across all repositories
          for repo in "${REPOS[@]}"; do
            echo "Checking $repo repository..."

            # Get latest tag for current repository
            CURRENT_TAG=$(aws ecr describe-images \
              --repository-name $repo \
              --query 'sort_by(imageDetails,& imagePushedAt)[-1].imageTags[0]' \
              --output text)

            # Skip if no tags found
            if [ "$CURRENT_TAG" == "None" ]; then
              continue
            fi

            # Extract version number
            CURRENT_VERSION=$(echo $CURRENT_TAG | sed 's/dev-v//')

            # Compare versions
            if [ "$(printf '%s\n' "$LATEST_VERSION" "$CURRENT_VERSION" | sort -V | tail -n1)" = "$CURRENT_VERSION" ]; then
              LATEST_VERSION=$CURRENT_VERSION
              LATEST_TAG=$CURRENT_TAG
            fi
          done

          # If no tags found in any repository, start with 1.0.0
          if [ "$LATEST_VERSION" == "0.0.0" ]; then
            new_tag="dev-v1.0.0"
          else
            # Extract and increment version
            major=$(echo $LATEST_VERSION | cut -d. -f1)
            minor=$(echo $LATEST_VERSION | cut -d. -f2)
            patch=$(echo $LATEST_VERSION | cut -d. -f3)
            new_patch=$((patch + 1))
            new_tag="dev-v${major}.${minor}.${new_patch}"
          fi

          # Create and push new git tag
          git tag $new_tag
          git push origin $new_tag

          echo "New tag: $new_tag"
          echo "new_tag=$new_tag" >> $GITHUB_OUTPUT

  release:
    needs: create-tag
    name: "Release"
    runs-on: ubuntu-latest
    environment: development
    env:
      IMAGE_TAG: ${{ needs.create-tag.outputs.new_tag }}
      ECS_CLUSTER: arn:aws:ecs:${{ secrets.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:cluster/NexionAiIacStack-ServicesCluster3EE15C94-nf3Z7FKfOwlj

    steps:
      - uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-ecs-role
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1


      - name: Build and push images to Amazon ECR
        id: build-images
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          declare -A SERVICES=(
            ["waltid-issuer-api"]="IssuerContainer|NexionAiIacStackIssuerTaskDefinition4AF6EAF7|waltid-services/waltid-issuer-api/Dockerfile|arn:aws:ecs:${{ secrets.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:service/NexionAiIacStack-ServicesCluster3EE15C94-nf3Z7FKfOwlj/NexionAiIacStack-IssuerServiceA12C5401-MOLwTFpgCzkt"
            ["waltid-verifier-api"]="VerifierContainer|NexionAiIacStackVerifierTaskDefinition4228B84F|waltid-services/waltid-verifier-api/Dockerfile|arn:aws:ecs:${{ secrets.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:service/NexionAiIacStack-ServicesCluster3EE15C94-nf3Z7FKfOwlj/NexionAiIacStack-VerifierServiceCD2CC6E9-UhMVd8ifZpvD"
            ["waltid-wallet-api"]="WalletApiContainer|NexionAiIacStackWalletApiTaskDefinitionAD56EEDD|waltid-services/waltid-wallet-api/Dockerfile|arn:aws:ecs:${{ secrets.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:service/NexionAiIacStack-ServicesCluster3EE15C94-nf3Z7FKfOwlj/NexionAiIacStack-WalletApiService43CA521A-YN4fIxAhYCcv"
            ["waltid-demo-wallet"]="WaltidDemoWalletContainer|NexionAiIacStackWaltidDemoWalletTaskDefinitionF3F49765|waltid-applications/waltid-web-wallet/apps/waltid-demo-wallet/Dockerfile|arn:aws:ecs:${{ secrets.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:service/NexionAiIacStack-ServicesCluster3EE15C94-nf3Z7FKfOwlj/NexionAiIacStack-WaltidDemoWalletServiceA20610D0-nvqBzCKJAZtQ"
            ["waltid-web-portal"]="WaltidWebPortalContainer|NexionAiIacStackWaltidWebPortalTaskDefinitionCB8A832C|waltid-applications/waltid-web-portal/Dockerfile|arn:aws:ecs:${{ secrets.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:service/NexionAiIacStack-ServicesCluster3EE15C94-nf3Z7FKfOwlj/NexionAiIacStack-WaltidWebPortaltService75F4E2F5-kZSulveJ6dvy"
          )
          
          # Array to track successful builds
          declare -a BUILT_SERVICES=()
          
          for service in "${!SERVICES[@]}"; do
            IFS='|' read -r container_name task_def dockerfile service_name <<< "${SERVICES[$service]}"
            echo "Building and pushing $service..."
            echo "Using Dockerfile: $dockerfile"
            
            if ! docker build -t $ECR_REGISTRY/$service:$IMAGE_TAG -f $dockerfile .; then
              echo "Failed to build $service"
              # Clean up any successful builds
              for built in "${BUILT_SERVICES[@]}"; do
                echo "Removing pushed image for $built"
                aws ecr batch-delete-image \
                  --repository-name $built \
                  --image-ids imageTag=$IMAGE_TAG
              done
              exit 1
            fi
            
            if ! docker push $ECR_REGISTRY/$service:$IMAGE_TAG; then
              echo "Failed to push $service"
              # Clean up any successful builds
              for built in "${BUILT_SERVICES[@]}"; do
                echo "Removing pushed image for $built"
                aws ecr batch-delete-image \
                  --repository-name $built \
                  --image-ids imageTag=$IMAGE_TAG
              done
              exit 1
            fi
            
            BUILT_SERVICES+=($service)
          done

      - name: Update task definitions and services
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          declare -A SERVICES=(
            ["waltid-issuer-api"]="IssuerContainer|NexionAiIacStackIssuerTaskDefinition4AF6EAF7|waltid-services/waltid-issuer-api/Dockerfile|arn:aws:ecs:${{ secrets.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:service/NexionAiIacStack-ServicesCluster3EE15C94-nf3Z7FKfOwlj/NexionAiIacStack-IssuerServiceA12C5401-MOLwTFpgCzkt"
            ["waltid-verifier-api"]="VerifierContainer|NexionAiIacStackVerifierTaskDefinition4228B84F|waltid-services/waltid-verifier-api/Dockerfile|arn:aws:ecs:${{ secrets.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:service/NexionAiIacStack-ServicesCluster3EE15C94-nf3Z7FKfOwlj/NexionAiIacStack-VerifierServiceCD2CC6E9-UhMVd8ifZpvD"
            ["waltid-wallet-api"]="WalletApiContainer|NexionAiIacStackWalletApiTaskDefinitionAD56EEDD|waltid-services/waltid-wallet-api/Dockerfile|arn:aws:ecs:${{ secrets.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:service/NexionAiIacStack-ServicesCluster3EE15C94-nf3Z7FKfOwlj/NexionAiIacStack-WalletApiService43CA521A-YN4fIxAhYCcv"
            ["waltid-demo-wallet"]="WaltidDemoWalletContainer|NexionAiIacStackWaltidDemoWalletTaskDefinitionF3F49765|waltid-applications/waltid-web-wallet/apps/waltid-demo-wallet/Dockerfile|arn:aws:ecs:${{ secrets.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:service/NexionAiIacStack-ServicesCluster3EE15C94-nf3Z7FKfOwlj/NexionAiIacStack-WaltidDemoWalletServiceA20610D0-nvqBzCKJAZtQ"
            ["waltid-web-portal"]="WaltidWebPortalContainer|NexionAiIacStackWaltidWebPortalTaskDefinitionCB8A832C|waltid-applications/waltid-web-portal/Dockerfile|arn:aws:ecs:${{ secrets.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:service/NexionAiIacStack-ServicesCluster3EE15C94-nf3Z7FKfOwlj/NexionAiIacStack-WaltidWebPortaltService75F4E2F5-kZSulveJ6dvy"
          )
          
          # Download all task definitions first
          echo "Downloading current task definitions..."
          for service in "${!SERVICES[@]}"; do
            IFS='|' read -r container_name task_def dockerfile service_name <<< "${SERVICES[$service]}"
            echo "Downloading task definition for $service..."
            
            if ! aws ecs describe-task-definition --task-definition $task_def \
              --query taskDefinition > task-definition-$service.json; then
              echo "Failed to download task definition for $service"
              exit 1
            fi
          done

          # Store current task definitions for rollback
          declare -A CURRENT_TASK_DEFS=()
          declare -a UPDATED_SERVICES=()
          
          # Get current task definitions
          for service in "${!SERVICES[@]}"; do
            IFS='|' read -r container_name task_def dockerfile service_name <<< "${SERVICES[$service]}"
            CURRENT_TASK_DEFS[$service]=$(aws ecs describe-services \
              --cluster $ECS_CLUSTER \
              --services "$service_name" \
              --query 'services[0].taskDefinition' \
              --output text)
          done

          # Update services
          for service in "${!SERVICES[@]}"; do
            IFS='|' read -r container_name task_def dockerfile service_name <<< "${SERVICES[$service]}"
            
            # Update task definition
            if ! jq --arg IMAGE "$ECR_REGISTRY/$service:$IMAGE_TAG" \
             --arg NAME "$container_name" \
             '{
                family: .family,
                taskRoleArn: .taskRoleArn,
                executionRoleArn: .executionRoleArn,
                networkMode: .networkMode,
                containerDefinitions: (.containerDefinitions | map(
                  if .name == $NAME then . + {image: $IMAGE} else .
                  end
                )),
                requiresCompatibilities: .requiresCompatibilities,
                cpu: .cpu,
                memory: .memory,
                volumes: .volumes
              }' \
               task-definition-$service.json > updated-task-definition-$service.json; then
              echo "Failed to update task definition JSON for $service"
              goto_rollback=1
              break
            fi

            # Register new task definition
            echo "Registering new task definition for $service..."
            NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
              --cli-input-json file://updated-task-definition-$service.json \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)
            
            if [ $? -ne 0 ]; then
              echo "Failed to register task definition for $service"
              goto_rollback=1
              break
            fi
            
            # Update service
            if ! aws ecs update-service \
              --cluster $ECS_CLUSTER \
              --service "$service_name" \
              --task-definition $NEW_TASK_DEF_ARN \
              --force-new-deployment; then
              echo "Failed to update service for $service"
              goto_rollback=1
              break
            fi
            
            UPDATED_SERVICES+=($service)
            
            # Wait for service to stabilize
            echo "Waiting for $service to stabilize..."
            if ! aws ecs wait services-stable \
              --cluster $ECS_CLUSTER \
              --services "$service_name"; then
              echo "Service $service failed to stabilize"
              goto_rollback=1
              break
            fi
          done
          
          # Rollback if needed
          if [ "${goto_rollback:-0}" -eq 1 ]; then
            echo "Deployment failed, rolling back updated services..."
            for service in "${UPDATED_SERVICES[@]}"; do
              IFS='|' read -r container_name task_def dockerfile service_name <<< "${SERVICES[$service]}"
              echo "Rolling back